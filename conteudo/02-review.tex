\chapter{Background}
\label{cap:literature}

\enlargethispage{.5\baselineskip}

This chapter serves as an overview of the terms and foundational concepts used throughout this work. It acts as a baseline, ensuring a common understanding of the key ideas and terminology essential for the development and discussion of the project.

\section{Metrics}
\label{sec:metrics}
Metrics are a representation of an object’s characteristic as a numeric value(~\cite{OOMetrics}). In association with units of measurement and thresholds, metrics are used to describe the object and also to assess it.

In software development, metrics are used to describe many aspects of a system, from objective characteristics – like response time and CPU usage, that have standards and well-defined ways of measurement –, to subjective ones – like code quality and software maintainability, which can be measured by several methods, each one of them with its efficiency and accuracy.

The assessment made with metrics can go in different directions, such as to track if a certain goal has been achieved, or to follow if a specific requirement is being respected. In general, different metrics can be used to assess a single characteristic, but the choice depends on the goal of the analysis. For example, to represent the degree of coupling between modules A and B, we can use the static number of function calls, or we can use the dynamic number of calls per minute during execution.

\section{Software Architecture}
\label{sec:softarq}
Software Architecture is an area of study in computer science that focuses on software structures, their benefits and drawbacks, and how to integrate them to solve problems(~\cite{SoftArch}).

The architecture of the software is what describes which set of structures are used to build a system, encompassing its components, principles, responsibilities, and design decisions. It doesn't necessarily establish implementation details, like technologies, design patterns, and intra-component architecture, it depends on the level of detail and how big is the whole structure. However, all decisions taken in the architecture should be necessary to reason about the software and its implementation.

\subsection*{Non-functional Requirements}
\label{sec:nonfunctional}
When defining a software's architecture, there are a set of requirements that should be fulfilled, so the software solves the problem it was intended to. These requirements can be split into two groups: functional and non-functional. Functional requirements describe what the software should do, and the behavior. Non-functional requirements define how this should be done, and the qualities.

Non-functional requirements should be as well-defined as the functional ones. For example, a live chat API should allow two users to interact with each other at the same time, with a maximum 500ms delay to message delivery. This not only defines what is the API functionality, but also that it should be performant, and this requirement is as important as the functionality since an API with slow response time does not fully solve the problem.

\subsection*{Extensibility}
\label{sec:extensibility}
Extensibility is the quality of what can be extended(~\cite{Evoluctionary}). In the context of software, a system or architecture can be said extensible if it is able to receive new features without requiring major changes. 

Features are capacities added to a component that doesn't change its functionality. Extensibility should be achieved without violating the single-responsibility principle.

For example, a component designed to translate text from Portuguese to English can be said extensible if it doesn't require major changes to implement translation from Portuguese to Spanish. The system does a new thing, however it still with the single functionality of translating.

\section{Microservices}
\label{sec:microservices}
In the past, the development of a software system could be explained as a line, with planning, beginning, and ending delivery. With technological advances, continuous delivery emerged, turning this process into a cycle that can be repeated without ever reaching a final delivery. In this scenario, companies started to have problems scaling large monolithic applications, because they require knowledge about the system for changes, this knowledge usually ended up concentrated in a few developers that took part in the building of the application. This leads to business changes being held by engineering limitations. Microservice comes up as a solution that allows fast-paced development in large systems and fits better the necessities of a fast delivery market. 

Microservice is a software architecture style, in which, the responsibilities and business functionalities are split into independently deployable components, each component has its codebase and is called a "microservice"(~\cite{Micro}). These services communicate through APIs, Application Programming Interfaces, that work as contracts, containing rules, protocols, and tools, that other services may follow to be able to communicate(~\cite{Microservices}).

Microservices components follow the rule of single responsibility, where each component is responsible for doing only one thing. This allows organizations to split the concerns into multiple cores, each with its own sets of services where the ramp-up and specialization are easier since each core can be focused on a specific area. For example, a common split of teams on big techs is in functional areas: mobile client, web client, data management, back-end development, etc.

The Microservice architecture approach also allows splitting the decision in multiple layers. While a software architect may be responsible for defining which services take part in a certain flow, and what are their responsibilities, the technical and design decisions of implementation can be made by the maintainer development team, since each component is technology independent.

Another advantage of microservice is scalability and extensibility. As components are independent, it is possible to scale only required components at a time and cut costs. It also means that adding a new feature can be as easy as creating a new independent service and attaching it to the architecture.

However, this architecture relies on inter-component contracts, which means that any break in a contract can lead to a cascade of unwanted behaviors that require lots of tracking and measurements to debug. It also demands an increase in design complexity and operational cost due to the necessity of handling multiple services, their deployment, and integration.
